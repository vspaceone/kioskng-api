'use strict';

const { 
    DynamoDBClient, 
    GetItemCommand, ScanCommand, PutItemCommand, DeleteItemCommand, QueryCommand,
    ConditionalCheckFailedException } = require("@aws-sdk/client-dynamodb");
const { marshall, unmarshall } = require("@aws-sdk/util-dynamodb");

const {DatabaseOperationException, DataConflictException} = require('../utils/exceptions.js')
const ProductDynamoRestfulHandler = require('../products/DynamoRestfulHandler.js').DynamoRestfulHandler;

const productModule = require('../products/app.js');
const ProductPayloadValidators = productModule.PayloadValidators;
const productRegion = productModule.region;
const productTableName = productModule.tableName;

const { time } = require("console");
const crypto = require('crypto');

class DynamoRestfulHandler {

    constructor(region, tableName, payloadValidator) {
        this.ddClient = new DynamoDBClient({region: region});
        this.defaultPageSize = 10;
        this.tableName = tableName;
        this.payloadValidator = payloadValidator;

        this.productDynamoRestfulHandler = new ProductDynamoRestfulHandler(productRegion, productTableName, new ProductPayloadValidators())
    }

    async handleApiEvent(event){
        switch (event.httpMethod){
            case "GET":
                return await this.handleGet(event);
            case "PUT":
                return await this.handlePut(event);
            case "DELETE":
                return await this.handleDelete(event);
            default:
                return { statusCode: 501 }
        }
    }

    // ##################
    // ##### DELETE #####
    // ##################

    async handleDelete(event){
        // TODO Transactions by design can NEVER be deleted, only a cancellation transaction can be made

        // TODO get transaction by event.pathParameters.id

        // TODO reuse this transaction but set action to CANCEL, negate the amount and recalculate the result
        
        return { statusCode: 501 }
    }

    // ###############
    // ##### PUT #####
    // ###############

    async handlePut(event){
        const item = JSON.parse(event.body)
        const validate = this.payloadValidator.generatePutTransactionValidator();

        const valid = validate(item);

        if (!valid) {
            return {
                statusCode: 422,
                body: JSON.stringify(validate.errors)
            }
        }

        let data;
        try {
            data = await this.putTransaction(item)
        } catch (e) {
            if (e instanceof DatabaseOperationException){
                return {
                    statusCode: 500,
                    body: e.message
                }
            } else if (e instanceof DataConflictException){
                return {
                    statusCode: e.suggestedStatusCode,
                    body: e.message
                }
            }
            return {
                statusCode: 500,
                body: "Unhandled error"
            }
        }
        
        return {
            statusCode: 200,
            body: data
        }
    }

    async putTransaction(transactionData){
        const transactionUUID = crypto.randomUUID();
        const timestamp = Math.trunc(new Date().getTime() / 1000);

        transactionData.id = transactionUUID;
        transactionData.timestamp = timestamp;

        // TODO validate if account_id, action, auth and location have plausible values or generate them
        // TODO -> account_id and auth+device shall be autogenerated when called from non PoS context to always match currently logged in user
        // TODO -> account_id is open to be announced by a PoS when auth+device correct for account_id not sure though how to exactly implement this yet
        
        const lastTransaction = await this.getMostRecentItemByAccountIDAndTimestamp(transactionData.account_id);
        // TODO get "last" transaction for same account_id or assume to start off with 0 balance
        // TODO the last transaction must be queried "strongly consistent" to make sure it reflect the most recent value
        let assumedLastBalance = 0;
        if (lastTransaction && lastTransaction.transaction_result !== undefined){
            assumedLastBalance = lastTransaction.transaction_result
        }

        // TODO check plausibility of item.transaction_amount in comparison with item.action, if the latter is "BUY_PRODUCT" then we need to always retrieve price from products table
        if (transactionData.action === "WITHDRAW") {
            if (!(transactionData.transaction_amount < 0)){
                throw new DataConflictException("WITHDRAW action was specified but item.transaction_amount is not a negative number", 406);
            }

        } else if (transactionData.action === "DEPOSIT") {
            if (!(transactionData.transaction_amount > 0)){
                throw new DataConflictException("DEPOSIT action was specified but item.transaction_amount is not a positive number", 406);
            }
        } 
        
        if (transactionData.action === "BUY_PRODUCT" && transactionData.product !== undefined && transactionData.product.ean !== undefined && transactionData.transaction_amount === undefined){
            const selectedProduct = await this.productDynamoRestfulHandler.getItemByEan(transactionData.product.ean);

            if (selectedProduct === null){
                throw new DataConflictException("BUY_PRODUCT action was specified but transactionData.product.ean is not a known products ean", 404);
            }

            if (selectedProduct.ean !== transactionData.product.ean){
                throw new DataConflictException("Internal error: ean mismatch", 500);
            }
            
            transactionData.transaction_amount = -selectedProduct.price;
            transactionData.product = selectedProduct;
        } else if (transactionData.action === "BUY_PRODUCT") {
            // TODO If no products specified this operation should fail
            throw new DataConflictException("BUY_PRODUCT action was specified but no valid value for product.ean was found or transaction amount is set", 406);
        }

        transactionData.transaction_result = assumedLastBalance + transactionData.transaction_amount;       
        
        const command = new PutItemCommand({
            TableName: this.tableName,
            Item: marshall(transactionData)
        });

        let response;
        try {
            response = await this.ddClient.send(command);
        } catch (e) {
            throw new DatabaseOperationException("Error while calling DynamoDB.", e);
        }
        
        return transactionData;
    }

    // ###############
    // ##### GET #####
    // ###############

    async handleGet(event){
        try {
            let data;
            if (event && event.pathParameters && event.pathParameters.id){
                data = await this.getItemByID(event.pathParameters.id)
            } else if (event && event.queryStringParameters && event.queryStringParameters.account_id && event.queryStringParameters.latest === "true"){
                data = await this.getMostRecentItemByAccountIDAndTimestamp(event.queryStringParameters.account_id)
            } else if (event && event.queryStringParameters && event.queryStringParameters.account_id){
                data = await this.getItemByAccountID(event.queryStringParameters.account_id)
            } else {
                data = await this.getItems();
            }

            if (data === null){
                return {
                    statusCode: 404
                }
            }

            return {
                statusCode: 200,
                body: JSON.stringify(data)
            }
        } catch (e) {
            if (e instanceof DatabaseOperationException){
                return {
                    statusCode: 500,
                    body: e.message
                }
            }
            return {
                statusCode: 500,
                body: "Unhandled error"
            }
        }
    }

    async getItemByID(id){
        const command = new GetItemCommand({TableName: this.tableName, Key: marshall({ id: id })})
        let item;
        
        try {
            item = await this.ddClient.send(command);
        } catch (e) {
            throw new DatabaseOperationException("Error while calling DynamoDB.", e);
        }

        if (!item.Item){
            return null;
        }

        return unmarshall(item.Item);
    }

    async getItemByAccountID(id){
        const command = new QueryCommand(
            {
                TableName: this.tableName,
                IndexName: 'account_id-timestamp-index',
                KeyConditionExpression: 'account_id = :id',
                ExpressionAttributeValues: marshall({
                    ":id": id
                })
            });
        let item;
        
        try {
            item = await this.ddClient.send(command);
        } catch (e) {
            throw new DatabaseOperationException("Error while calling DynamoDB.", e);
        }

        const unmarshalledItems = item.Items.map((i) => unmarshall(i));

        if (unmarshalledItems.length === 0){
            return null;
        }

        return unmarshalledItems;
    }

    async getMostRecentItemByAccountIDAndTimestamp(id){
        const command = new QueryCommand(
            {
                TableName: this.tableName,
                IndexName: 'account_id-timestamp-index',
                KeyConditionExpression: 'account_id = :id',
                // Limit 1 and ScanIndexForward false make sure we retrieve the element with highest timestamp value efficiently
                Limit: 1,
                ScanIndexForward: false,
                ExpressionAttributeValues: marshall({
                    ":id": id
                })
            });
        let item;
        
        try {
            item = await this.ddClient.send(command);
        } catch (e) {
            throw new DatabaseOperationException("Error while calling DynamoDB.", e);
        }

        const unmarshalledItems = item.Items.map((i) => unmarshall(i));

        if (unmarshalledItems.length === 0){
            return null;
        }

        return unmarshalledItems[0];
    }

    async getItems(){
        const command = new ScanCommand({TableName: this.tableName});
        let item;

        try {
            item = await this.ddClient.send(command);
        } catch (e) {
            throw new DatabaseOperationException("Error while calling DynamoDB.", e);
        }

        const unmarshalledItems = item.Items.map((i) => unmarshall(i));
        
        return unmarshalledItems;
    }

}

exports.DynamoRestfulHandler = DynamoRestfulHandler;